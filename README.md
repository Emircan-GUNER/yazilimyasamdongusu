Yazılım Geliştirme Süreç Modelleri
Herhangi bir projeyi geliştirme yalnızca kodlamadan oluşmamaktadır. Öncelikle yazılım geliştirme yaşam döngüsü bulunmaktadır. Yazılımın hem üretim, hem de kullanım süreci boyunca geçirdiği tüm aşamalar yazılım geliştirme yaşam döngüsü olarak adlandırılır. Yazılım fonksiyonları ile alakalı gereksemeler sürekli olarak değiştiği ve genişlediğinden, söz konusu evreler devamlı bir döngü biçiminde ele alınır. Döngü içinde her hangi bir evrede geriye dönmek ve bir daha ilerlemek mevzu bahistir. Bu döngünün de temel bazı adımları vardır. Bunlar; Planlama, Analiz, Tasarım, Gerçekleştirim ve Bakım olarak sıralanırlar.Projenin hedeflerine ulaşabilmesi için türlü süreç ve yöntemler mevcuttur. Her bir süreç modeli, başarılı olmak için yazılım geliştirmede bu yaşam döngüsünü takip eder. Yazılım süreç modelleri üretilenlerin kalitesine pozitif etkisinin yanında, projelerin karışıklığını hafifletip karmaşıklıkları önler. Yazılım Şirketleri projenin amaçlarına vara bilmesi için geliştirilmiştir.
Yazılım Süreci Modelleri
Bunlar yazılım üretim faaliyetinin genel yapılma düzenine dair rehberler olarak adlandırılırlar. Bu modeller asla süreçlere ilişkin ayrıntılarla veyahut da süreçler arası ilişkilerle de ilgilenmezler.
Prototipleme (Prototyping)
Gereksinimler hızlıca toplanarak işe başlanılır. Geliştiriciler ve kullanıcılar aynı masa etrafında buluşarak yazılımdan elde edilecek bütün çıktılara, bu çıktılar için gerekli girdilerin nasıl sağlanacağına, nasıl korunacağına, hangi işlemlere uğrayacağına karar verirler. Daha sonra hızlıca yapılan bir tasarım ile yazılımın kullanıcıya yansıyacak yönünü aktaran bir ilk örnek üretilir. Prototip kullanıcının kullanımına ve değerlendirilmesine sunulur. Bu değerlendirmelere bakılarak ilk örnek üzerinde gerekli değişiklikler yapılır. Prototipin yeni hali kullanıcı tarafından yeniden değerlendirilir. Böylece kullanıcının istediği yazılıma iyice yaklaşılmış bir ilk örnek üzerinde yazılımın neler yapacağı konusunda kullanıcı ile anlaşmaya varılır. Doğrusal modelin döngüsel versiyonudur. Bu modelde, gereksinim analizi ve prototipleme için tasarım yapıldıktan sonra, geliştirme süreci başlatılır. Prototipleme yaratıldıktan sonra, müşteriye değerlendirme için verilir. Müşteri paketi test eder ve düşüncelerini, ürünü müşterinin tam beklentilerine göre düzenleyen geliştiriciye iletir. Sınırlı sayıdaki yinelemelerden sonra, son yazılım paketi müşteriye verilir. Bu metodolojide, yazılım müşteri ve geliştirici arasında periyodik bilgi gidip gelmeleri sonucunda gelişir.
                  

Avantajları
•	Kullanıcı sistem gereksinimlerini görebilir
•	Karmaşa ve yanlış anlaşılmaları engeller
•	Yeni ve beklenmeyen gereksinimler netleştirilebilir
•	Risk kontrolü sağlanır 
Dezavantajları
•	Belgelendirmesi olmayan hızlı ve kirli (quick and dirty) prototipler
•	Prototip hedefleri net d
•	eğilse kod hackleme ya da jenga başlar
•	Düzeltme aşaması atlanırsa, düşük performansa yol açar
•	Müşteri prototipten de son ürün gibi görünüm ve etki bekler.
Evrimsel Geliştirme Süreç Modeli
Bu  model İlk tam ölçekli olan modeldir. Başarısı ilk evrimin başarısına bağımlı haldedir. Tüm aşamalarda üretilen ürünler, üretildikleri yer için tam fonksiyonelliği içermektedirler.Zayıf yanıysa değişiklik denetimine sahip olmamasıdır. Modelin yapılandırma, kalite, sürüm ve değişiklik yönetimi biraz problemlidir.
İki çeşit evrimsel geliştirme vardır:
•	Keşifçi geliştirme (exploratorydevelopment) 
o	Hedef: Müşterinin gereksinimlerini incelemek için müşteri ile çalışıp son sistemi teslim etmek
o	İyi anlaşılan gereksinimlerle başlanmalıdır
•	Atılacak prototipleme(throw-awayprototyping)
o	Hedef: Sistem gereksinimlerini anlamak
o	Tam anlaşılmamış gereksinimlerle başlar 

                   
Avantajları
•	Kullanıcıların kendi gereksinimlerini daha iyi anlamalarını sağlar
•	Sürekli değerlendirme erken aşamalardaki geliştirme risklerini azaltır
•	Hatalar azalır 
Dezavantajları
•	Sürecin görünürlüğü azdır (düzenli teslim edilebilir ürün yoktur)
•	Sistemler sıklıkla iyi yapılandırılmaz (sürekli değişiklik yazılımın yapısına zarar verir)
•	Bakımı zordur
•	Yazılım gereksinimini yenilemek gerekebilir
Kodla ve Düzelt Model
Bu model genellikle resmi olmayan bir ürün fikriyle başlar ve program ürün “hazır” olana kadar ya da gerekli zaman bitene kadar kodlama yapılarak devam eder.
Avantajları 
•	Herhangi bir planlamaya ihtiyaç duyulmaz
•	Çok küçük projelerde ya da kısa ömürlü prototiplerde uygulanabilir
•	Program aşamaları çabuk geçilir 
•	Uzman görüşüne ihtiyaç düşüktür herkes bu modeli kullanabilir
Dezavantajları
•	Kontrollü değildir.
•	Kaynak planlaması yoktur 
•	Bitiş süresi belli değildir
•	Hataların bulunması ve doğrulaması zordur
•	Kodları düzeltmek maliyetli olabilir 
•	Kodlar kullanıcının ihtiyacını karşılamayabilir
•	Kodlar sonradan değiştirmek için planlanmadığından esnek değildir, değiştirilmesi zordur
                
o	V Modeli
V-model(yazılım geliştirme) şelale(waterfall) modelinin gelişmiş hali olarak düşünülebilecek bir yazılım geliştirme süreci sunar. Doğrusal bir yönde ilerlemek yerine, süreç adımları kodlama evresinden sonra yukarıya doğru eğim alır ve tipik V şeklini oluşturur. V-Model geliştirme yaşam çevriminin her bir evresi arasındaki ilişkileri gösterir. Yatay ve dikey açılar zaman veya projenin tamamlanabilirliğini ve soyut seviyeyi gösterir. 
               
Avantajları

•	Verification ve validation planları erken aşamalarda vurgulanır
•	Verification ve validation sadece son üründe değil tüm teslim edilebilir ürünlerde uygulanır. 
•	Proje yönetimi tarafında takibi kolaydır
•	Kullanımı kolaydır 

Dezavantajları
•	Aynı zamanda gerçekleştirilebilecek olaylara kolay imkan tanımaz
•	Fazlar arasında tekrarlamaları kullanmaz
•	Risk çözümleme ile ilgili aktiviteleri içermez
•	Yazılım da diğer sistemler gibi zamanla evrimleşir
•	Geliştirme devam ettikçe iş ve ürün gereksinimleri de değişkenlik gösterebilir
•	Son ürüne ulaşma düz bir çizgi ile ifade edilemez

Çağlayan Modeli
Şelale yönteminde yazılım geliştirme süreci analiz, tasarım, kodlama, test, sürüm ve bakım gibi safhalardan oluşur. Geleneksel yazılım metotlarında bu safhalar şelale modelinde olduğu gibi lineer olarak işler. Her safha, başlangıç noktasında bir önceki safhanın ürettiklerini bulur. Kendi bünyesindeki değişikler doğrultusunda teslim aldıklarını bir sonraki safhanın kullanabileceği şekilde değiştirir. 
Avantajları
•	Kullanımı ve anlaması basittir
•	Yönetimi kolaydır
•	Projenin safhaları ayrı olduğundan iş bölümü ve iş planı projenin en başında net bir şekilde bellidir. Bu durum projenin yönetimini de oldukça kolay hale getirir. 
•	Şelale Modeli çok küçük ve gereksinimleri çok iyi anlaşılmış projelerde iyi çalışır. 
Dezavantajları
•	Karmaşık ve nesne yönelimli projeler için uygun değildir
•	Devam eden ve uzun projeler için zayıftır
•	Projede oluşabilecek her türlü değişime elverişsiz, katı bir modeldir. Yapılan her değişiklik maliyeti büyük oranda arttırır.
•	Müşteri memnuniyetini sağlamak çok zordur çünkü gelişim ve değişime açık bir model değildir. 
•	Model safhalardan oluştuğu için ürün son safhada tamamlanır,  gereksinimlerin iyi tanımlanmadığı müşterinin ne istediğinin anlaşılmadığı bir projede bu durum projenin bittikten sonra iptal edilmesine ve başka gerginliklere sebep olmaktadır.
Helezonik (Spiral) Model
Helezonik modeli diğerlerinden ayıran özellik ise risk analizinin ön planda olması ve prototip oluşturulmasıdır. Risk analizi ön planda olduğu için hataları erken giderme imkânı tanıyabilir. Prototip oluşturma da her aşamada olduğu için kullanıcı da her aşamada yazılım projesinin bir parçasını görme imkanına sahip olur bu da sorunların azalmasını sağlayabilir. 4 temel aşamadan oluşur:
•	Planlama: Her aşamada olan ara ürün için bir planlama yapılır.
•	Risk Analizi: Risklerin araştırılması, belirlenmesi ve çözülmesi.
•	Üretim: Ara ürünün/ürünün üretilmesi.
•	Kullanıcı Değerlendirme: Oluşturulan ara ürünün sonucunda kullanıcıdan alınan geri dönütlerin değerlendirilerek diğer aşamaya geçilmesi.
•	Helezonik modelin sorunları; küçük ve düşük riskli projeler için çok pahalı bir sistem olması, karmaşık bir içeriğe sahip olması, uzun sürmesi ve fazla dokümantasyondan oluşması olarak sıralanabilir
Artımsal Geliştirme Modeli
Artımlı Geliştirme Modelinde proje parçalara bölünür ve kullanıcının önceliğine göre bu parçalar sıralanır. Sıralanan bu parçalar bittiğinde sırasıyla birer ara ürün geliştirilmiş olur ve bu ara ürünler de kullanıcı tarafından kullanılır. Ara ürünler her seferinde bir öncekinin üstüne bir şeyler katarak çıkartılır. Yani bu modelde bir taraftan üretim kısmı sürerken diğer tarafta ise kullanım kısmı sürer. Artımlı geliştirme modeli uzun zaman alabilecek ve ürünün eksik işlevsellikle çalışabileceği türdeki yazılımlar için uygundur. Bu model ile sistemin başarısız olma olasılığı azalır, ara ürünler yazılımın geliştirilmesinde önemli bir yere sahip olur. Dezavantajları ise her bir parçanın kendi içinde tekrar etmesine izin verilmez bu yüzden de bir ara ürünün bitip diğeri başlayana kadar herhangi bir değişiklik yapılamaz, parçaları oluşturmak için de bu sistemin detaylı bir şekilde tanımlanması lazımdır.
Çevik Modeller
Çevik modeller yazılım projelerindeki başarı oranlarını ve ekip içi iletişimi arttırmak amacıyla ortaya çıkmıştır. Bazı çevik yazılım geliştirme modelleri şunlardır:
Extreme Programming (XP)
Kent Beck ve arkadaşları tarafından 1996 yılında kurulmuştur. 4 temel maddeden oluşur: Basitlik, Cesaret, Geri Dönüş, İletişim.
Basitlik: Yazılan kodun ve yapılan işin sade, anlaşılır ve karmaşık olmadan yapılmasını gerektirir. Uzun uzun dokümantasyondan uzak durulur.
Cesaret: Yapılan işte cesur olunmalıdır, projelerin üstüne korkmadan ilerlenmelidir. Bir kodun gerekirse tamamen silinip yeniden yazılması sağlanmalıdır.
Geri Dönüş: Geri dönüşler ile oluşabilecek hatalar azaltılır/ortadan kaldırılır. Müşteri ile yazılım ekibi birbirleriyle iletişim halindedir.
İletişim: İletişim, projelerde önemli sorunlardan birisidir. XP ise bunu aşmaya çalışmaktadır. Ekip içi iletişime önem verir ve artırılması için çalışır.
· SCRUM
SCRUM büyük projeleri parçalara bölerek her birine “sprint” adını verir. Projeyi böler ve her bir sprinti teker teker geliştirir. SCRUM’da ekip içi iletişim çok önemlidir öyle ki her gün “SCRUM MEETINGS” denen toplantılar yapılır. 

Formal Sistem Geliştirme (Formal System Development)
Formal Sistem Geliştirme Modeli yazılım tasarım ve gerçekleştirmesiyle ilgili matematiksel bir tekniktir. Bu modelin temelinde karmaşık sistemleri geliştirme ve program geliştirmeye destek yatar. Formal Sistem Geliştirme Metodu kullanıcı sistemi kullanmaya başladığında karşısına çıkan belirtim hatalarını minimize eder. 
Formal belirtim, tasarım ve geçerleme kullanarak yazılımda doğruluğun geliştirilmesini vurgular. Yazılım artımlarla geliştirilir. Sürekli tümleştirme vardır ve fonksiyonellik tümleştirilen yazılım artımları ile artar. Felsefesi pahalı hata ayıklama işlemini engellemek için kodu ilk yazarken doğru yazmak ve test aşamasından doğruluğunu sağlamaktır. 

Avantajları
•	Yazılımdaki belirsizlikleri, eksiklikleri ve uyumsuzlukları saptar.
•	Hatasız yazılım geliştirme imkanları sunar.
•	Her iterasyondan sonra aşamalı olarak artan efektif çözümler sunar.
•	Karmaşık değildir.

Dezavantajları
•	Çok zaman alan ve pahalı bir yöntemdir.
•	Kullanımı esnasında teknik olmayan personelle iletişim mekanizması zor işler.  
•	Sadece birkaç geliştirici bu modelin uygulamasıyla ilgili temel bilgilere sahip olması için yaygın eğitim gerektirir. 
Artımlı Geliştirme (Incremental Development)
Eğer bir müşterinin ürünlerinde değişikliğe ihtiyaçları varsa, artımlı model ihtiyaç olan bu değişikliğe ayak uydurur. Artırımsal model bir takvime bağlı olarak yazılımı kesim kesim geliştirip teslim etmeye dayanır. Her bir yeni kesim öncekinin üstüne bazı ek işlevlerin eklenmesini öngörür. Artırımsal model yazılım geliştirmenin kısıtlı sayıda çalışanla işin yapılmasını sağlama gibi bir üstünlüğü vardır. Ayrıca çalışanlar da her artırım geçildiğinde uygulama alanına ilişkin daha çok deneyim kazanmış olurlar.  Bu modelde bir taraftan üretim bir taraftan da kullanım yapılır. Önceki modellerde ürünlerdeki değişiklikler göz önünde bulundurulmaz. Bu model doğal olarak yinelemelidir. Yeniden kullanılabilir bir ürün, fonksiyonellik sağlamış bir şekilde tüm döngülerin sonunda ortaya çıkar. 
o	
Avantajları
•	Sistem için gerekli olan gereksinimler müşterilerle belirlenir.
•	Gereksinimlerin önemine göre teslim edilecek artımlar belirlenir
•	Öncelikle en önemli gereksinimleri karşılayan çekirdek bir sitem geliştirilir.
•	Erken artımlar prototip gibi davranarak, gereksinimlerin daha iyi anlaşılmasını sağlar
•	Tüm projenin başarısız olma riskini azaltır
•	En önemli sistem özellikleri daha fazla sınanma (test edilme) imkanı bulmuş olur.
•	Divide and Conquer (Böl ve Yönet) yaklaşımıdır
o	
Dezavantajları
•	Artımları tanımlamak için tüm sistemin tanımlanmasına ihtiyaç vardır
•	Gereksinimleri doğru boyuttaki artımlara atamak bazen zor olabilir.
•	Deneyimli personel gerektirir
•	Artımların kendi içlerinde tekrarlamalara izin vermez
Birleşik süreç (Unified Process)
Nesneye dayalı yazılım geliştirmek için var olan yöntemlerin deneyimler sonucu kabul gören en iyi özellikleri bir araya getirilerek tümleştirilmiş yazılım geliştirme süreci (The Unified Process - UP) oluşturulmuştur.Yinelemeli, arttırmalı ve evrimsel aynı zamanda da risk güdümlüdür. Birleşik süreçte yazılım geliştirme aşamaları şu şekildedir :
•	Başlangıç: Vizyon kararı, fizibilite çalışması, tamam ya da devam kararı.
•	Ayrıntılandırma: Daha gerçekçi çözümleme, çekirdek yapının ve yüksek riskli kısımların yinelemeli olarak oluşturulması.
•	Tamamlama: Daha az riskli ve düşük öncelikli kısımların yinelemeli olarak gerçeklenmesi.
•	Yayım: Beta testleri, piyasaya sürme çalışmaları.


Emircan Güner
